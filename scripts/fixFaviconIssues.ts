#!/usr/bin/env tsx

/**
 * Comprehensive Favicon Fix Script
 * Addresses common issues that prevent favicons from showing in search results
 */

import fs from 'fs';
import path from 'path';

class FaviconFixer {
  
  public async fixAllIssues(): Promise<void> {
    console.log('üîß Fixing Favicon Issues for Search Results...\n');
    
    await this.checkFaviconSizes();
    await this.validateFaviconFormats();
    await this.createRobotsTxtEntry();
    await this.generateSitemapEntry();
    await this.createHTAccessRules();
    await this.validateWebManifest();
    
    console.log('\n‚úÖ All favicon issues have been addressed!');
    console.log('\nüìã Next Steps for Google Search Results:');
    console.log('1. Deploy the updated website');
    console.log('2. Clear browser cache completely');
    console.log('3. Submit sitemap to Google Search Console');
    console.log('4. Request re-indexing of your homepage');
    console.log('5. Wait 24-48 hours for Google to update');
    console.log('6. Check Google Search Console for favicon errors');
  }

  private async checkFaviconSizes(): Promise<void> {
    console.log('üìè Checking favicon sizes...');
    
    const faviconPath = 'public/favicon.ico';
    if (fs.existsSync(faviconPath)) {
      const stats = fs.statSync(faviconPath);
      if (stats.size < 500) {
        console.log('‚ö†Ô∏è  favicon.ico is very small, might need regeneration');
      } else if (stats.size > 50000) {
        console.log('‚ö†Ô∏è  favicon.ico is very large, might slow down loading');
      } else {
        console.log('‚úÖ favicon.ico size is optimal');
      }
    }
  }

  private async validateFaviconFormats(): Promise<void> {
    console.log('üñºÔ∏è  Validating favicon formats...');
    
    const requiredFiles = [
      'public/favicon.ico',
      'public/favicon-16x16.png',
      'public/favicon-32x32.png',
      'public/apple-touch-icon.png'
    ];

    let allValid = true;
    for (const file of requiredFiles) {
      if (!fs.existsSync(file)) {
        console.log(`‚ùå Missing: ${file}`);
        allValid = false;
      } else {
        console.log(`‚úÖ Found: ${path.basename(file)}`);
      }
    }

    if (allValid) {
      console.log('‚úÖ All required favicon formats are present');
    }
  }

  private async createRobotsTxtEntry(): Promise<void> {
    console.log('ü§ñ Updating robots.txt...');
    
    const robotsPath = 'public/robots.txt';
    let robotsContent = '';
    
    if (fs.existsSync(robotsPath)) {
      robotsContent = fs.readFileSync(robotsPath, 'utf-8');
    }

    // Ensure favicon is not blocked
    if (!robotsContent.includes('Allow: /favicon.ico')) {
      robotsContent += '\n# Allow favicon\nAllow: /favicon.ico\nAllow: /favicon-*.png\nAllow: /apple-touch-icon.png\nAllow: /android-chrome-*.png\n';
      
      fs.writeFileSync(robotsPath, robotsContent);
      console.log('‚úÖ Updated robots.txt to allow favicon files');
    } else {
      console.log('‚úÖ robots.txt already allows favicon files');
    }
  }

  private async generateSitemapEntry(): Promise<void> {
    console.log('üó∫Ô∏è  Checking sitemap configuration...');
    
    // The sitemap is generated by Vite plugin, so we just verify it's configured
    const viteConfigPath = 'vite.config.ts';
    if (fs.existsSync(viteConfigPath)) {
      const content = fs.readFileSync(viteConfigPath, 'utf-8');
      if (content.includes('vite-plugin-sitemap')) {
        console.log('‚úÖ Sitemap plugin is configured');
      } else {
        console.log('‚ö†Ô∏è  Sitemap plugin not found in vite.config.ts');
      }
    }
  }

  private async createHTAccessRules(): Promise<void> {
    console.log('üîí Creating .htaccess rules for favicon...');
    
    const htaccessPath = 'public/.htaccess';
    let htaccessContent = '';
    
    if (fs.existsSync(htaccessPath)) {
      htaccessContent = fs.readFileSync(htaccessPath, 'utf-8');
    }

    const faviconRules = `
# Favicon caching and headers
<FilesMatch "\\.(ico|png|svg)$">
    ExpiresActive On
    ExpiresDefault "access plus 1 year"
    Header set Cache-Control "public, immutable"
</FilesMatch>

# Specific favicon rules
<Files "favicon.ico">
    Header set Content-Type "image/x-icon"
    Header set Cache-Control "public, max-age=31536000"
</Files>

# Prevent favicon 404 errors
RewriteEngine On
RewriteRule ^favicon\\.ico$ /favicon.ico [L]
`;

    if (!htaccessContent.includes('favicon.ico')) {
      htaccessContent += faviconRules;
      fs.writeFileSync(htaccessPath, htaccessContent);
      console.log('‚úÖ Added favicon rules to .htaccess');
    } else {
      console.log('‚úÖ .htaccess already has favicon rules');
    }
  }

  private async validateWebManifest(): Promise<void> {
    console.log('üì± Validating web manifest...');
    
    const manifestPath = 'public/site.webmanifest';
    if (fs.existsSync(manifestPath)) {
      try {
        const content = fs.readFileSync(manifestPath, 'utf-8');
        const manifest = JSON.parse(content);
        
        if (manifest.icons && manifest.icons.length > 0) {
          console.log(`‚úÖ Web manifest has ${manifest.icons.length} icons`);
        } else {
          console.log('‚ö†Ô∏è  Web manifest has no icons');
        }
        
        if (manifest.name && manifest.short_name) {
          console.log('‚úÖ Web manifest has proper names');
        } else {
          console.log('‚ö†Ô∏è  Web manifest missing name or short_name');
        }
      } catch (error) {
        console.log('‚ùå Web manifest has invalid JSON');
      }
    } else {
      console.log('‚ùå Web manifest not found');
    }
  }
}

async function main(): Promise<void> {
  const fixer = new FaviconFixer();
  await fixer.fixAllIssues();
}

main().catch(console.error);