#!/usr/bin/env tsx
/**
 * Page Generator Script
 * Generates 150 React component files for SEO-optimized service pages
 * 
 * Usage: npm run generate:pages or tsx scripts/generatePages.ts
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { pagesData } from '../src/data/generatedPagesData';
import { PageData } from '../src/types';
import { generateSEOOptimizedPages } from '../src/seo/integration/enhancedPageGenerator';

// Get directory paths
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');
const pagesDir = path.join(projectRoot, 'src', 'pages', 'generated');
const appFilePath = path.join(projectRoot, 'src', 'App.tsx');

// Statistics tracking
const stats = {
  filesCreated: 0,
  filesSkipped: 0,
  errors: [] as string[],
  warnings: [] as string[],
  routesGenerated: 0,
};

/**
 * Converts a string to PascalCase for component names
 * Example: "affordable-furniture-polishing-mumbai" -> "AffordableFurniturePolishingMumbai"
 */
function toPascalCase(str: string): string {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join('');
}

/**
 * Generates the filename for a page component
 * Example: "/services/affordable-furniture-polishing-mumbai" -> "AffordableFurniturePolishingMumbai.tsx"
 */
function generateFileName(url: string): string {
  // Remove /services/ prefix and convert to PascalCase
  const slug = url.replace('/services/', '');
  const componentName = toPascalCase(slug);
  return `${componentName}.tsx`;
}

/**
 * Generates the React component code for a page
 */
function generateComponentCode(pageData: PageData, componentName: string): string {
  // Escape special characters in strings for safe embedding in JSX
  const escapeString = (str: string) => str.replace(/`/g, '\\`').replace(/\$/g, '\\$');
  
  // Serialize the pageData object with proper formatting
  const pageDataString = JSON.stringify(pageData, null, 2)
    .replace(/"([^"]+)":/g, '$1:') // Remove quotes from object keys
    .replace(/: "([^"]*?)"/g, (match, p1) => {
      // Keep quotes for string values but escape them properly
      return `: "${p1.replace(/\\/g, '\\\\').replace(/"/g, '\\"')}"`;
    });
  
  return `/**
 * Auto-generated page component
 * Service: ${escapeString(pageData.serviceName)}
 * Location: ${escapeString(pageData.location)}
 * Generated: ${new Date().toISOString()}
 * 
 * DO NOT EDIT THIS FILE MANUALLY
 * This file is auto-generated by scripts/generatePages.ts
 * To update, modify the data in src/data/generatedPagesData.ts and regenerate
 */

import React from 'react';
import ServicePageTemplate from '../../components/ServicePageTemplate';
import { PageData } from '../../types';

const pageData: PageData = ${JSON.stringify(pageData, null, 2)};

const ${componentName}: React.FC = () => {
  return <ServicePageTemplate pageData={pageData} />;
};

export default ${componentName};
`;
}

/**
 * Creates the generated pages directory if it doesn't exist
 */
function ensureDirectoryExists(dirPath: string): void {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    console.log(`‚úì Created directory: ${dirPath}`);
  }
}

/**
 * Validates that the generated TypeScript code is syntactically valid
 * Basic validation - checks for balanced braces and proper structure
 */
function validateTypeScriptSyntax(code: string, fileName: string): boolean {
  try {
    // Check for balanced braces
    const openBraces = (code.match(/{/g) || []).length;
    const closeBraces = (code.match(/}/g) || []).length;
    
    if (openBraces !== closeBraces) {
      stats.errors.push(`${fileName}: Unbalanced braces (${openBraces} open, ${closeBraces} close)`);
      return false;
    }
    
    // Check for required imports
    if (!code.includes('import React') || !code.includes('import ServicePageTemplate')) {
      stats.errors.push(`${fileName}: Missing required imports`);
      return false;
    }
    
    // Check for export default
    if (!code.includes('export default')) {
      stats.errors.push(`${fileName}: Missing export default`);
      return false;
    }
    
    return true;
  } catch (error) {
    stats.errors.push(`${fileName}: Validation error - ${error}`);
    return false;
  }
}

/**
 * Generates a single page file
 */
function generatePageFile(pageData: PageData): boolean {
  try {
    const fileName = generateFileName(pageData.url);
    const componentName = fileName.replace('.tsx', '');
    const filePath = path.join(pagesDir, fileName);
    
    // Validate component name
    if (!/^[A-Z][a-zA-Z0-9]*$/.test(componentName)) {
      stats.errors.push(`Invalid component name: ${componentName} (from URL: ${pageData.url})`);
      return false;
    }
    
    // Check if file already exists
    if (fs.existsSync(filePath)) {
      stats.warnings.push(`File already exists: ${fileName} (skipping)`);
      stats.filesSkipped++;
      return true;
    }
    
    // Generate component code
    const componentCode = generateComponentCode(pageData, componentName);
    
    // Validate syntax
    if (!validateTypeScriptSyntax(componentCode, fileName)) {
      return false;
    }
    
    // Write file with error handling
    try {
      fs.writeFileSync(filePath, componentCode, 'utf-8');
      stats.filesCreated++;
      return true;
    } catch (writeError) {
      stats.errors.push(`Failed to write file ${fileName}: ${writeError}`);
      return false;
    }
  } catch (error) {
    stats.errors.push(`Failed to generate ${pageData.url}: ${error}`);
    return false;
  }
}

/**
 * Generates all page files
 */
function generateAllPageFiles(): void {
  console.log('\nüìÑ Generating page files...');
  console.log(`Target directory: ${pagesDir}\n`);
  
  // Ensure directory exists
  ensureDirectoryExists(pagesDir);
  
  // Generate each page
  let successCount = 0;
  for (let i = 0; i < pagesData.length; i++) {
    const pageData = pagesData[i];
    const success = generatePageFile(pageData);
    
    if (success) {
      successCount++;
      if ((i + 1) % 10 === 0) {
        console.log(`  Generated ${i + 1}/${pagesData.length} pages...`);
      }
    }
  }
  
  console.log(`\n‚úì Page generation complete: ${successCount}/${pagesData.length} pages`);
}

/**
 * Updates App.tsx with generated routes
 */
function updateAppRoutes(): void {
  console.log('\nüîÑ Updating routing configuration...');
  
  try {
    // Check if App.tsx exists
    if (!fs.existsSync(appFilePath)) {
      stats.errors.push(`App.tsx not found at ${appFilePath}`);
      console.error(`‚ùå App.tsx not found`);
      return;
    }
    
    // Read current App.tsx
    let appContent = fs.readFileSync(appFilePath, 'utf-8');
    
    // Backup original file
    const backupPath = appFilePath + '.backup';
    fs.writeFileSync(backupPath, appContent, 'utf-8');
    console.log(`  ‚úì Created backup: ${backupPath}`);
    
    // Generate lazy imports
    const lazyImports: string[] = [];
    const routeElements: string[] = [];
    
    for (const pageData of pagesData) {
      const fileName = generateFileName(pageData.url);
      const componentName = fileName.replace('.tsx', '');
      
      lazyImports.push(`const ${componentName} = lazy(() => import('./pages/generated/${componentName}'));`);
      routeElements.push(`              <Route path="${pageData.url}" element={<${componentName} />} />`);
    }
    
    // Remove existing auto-generated imports
    const autoGenStartMarker = '// Auto-generated page imports';
    const autoGenStartIndex = appContent.indexOf(autoGenStartMarker);
    
    if (autoGenStartIndex !== -1) {
      // Find the end of auto-generated imports (next non-import line or next comment)
      const afterMarker = appContent.substring(autoGenStartIndex);
      const nextSectionMatch = afterMarker.match(/\n\n(?!const\s+\w+\s*=\s*lazy)/);
      
      if (nextSectionMatch && nextSectionMatch.index) {
        const endIndex = autoGenStartIndex + nextSectionMatch.index;
        appContent = appContent.slice(0, autoGenStartIndex) + appContent.slice(endIndex);
        console.log(`  ‚úì Removed existing auto-generated imports`);
      }
    }
    
    // Find the position to insert lazy imports (after the last lazy import)
    // Look for the pattern: const SomeName = lazy(() => import('./pages/...'));
    const lazyImportRegex = /const\s+\w+\s*=\s*lazy\(\s*\(\s*\)\s*=>\s*import\([^)]+\)\s*\);/g;
    const lastLazyImportMatch = appContent.match(lazyImportRegex);
    
    if (!lastLazyImportMatch || lastLazyImportMatch.length === 0) {
      stats.warnings.push('Could not find existing lazy imports in App.tsx');
    } else {
      const lastLazyImport = lastLazyImportMatch[lastLazyImportMatch.length - 1];
      const lastImportIndex = appContent.lastIndexOf(lastLazyImport);
      const insertPosition = lastImportIndex + lastLazyImport.length;
      
      // Insert generated lazy imports
      const importsSection = '\n\n// Auto-generated page imports\n' + lazyImports.join('\n');
      appContent = appContent.slice(0, insertPosition) + importsSection + appContent.slice(insertPosition);
      console.log(`  ‚úì Added ${lazyImports.length} lazy imports`);
    }
    
    // Remove existing auto-generated routes
    const routesStartMarker = '{/* Auto-generated service pages */}';
    const routesStartIndex = appContent.indexOf(routesStartMarker);
    
    if (routesStartIndex !== -1) {
      // Find the end of auto-generated routes (before </Routes>)
      const afterRoutesMarker = appContent.substring(routesStartIndex);
      const routesEndMatch = afterRoutesMarker.match(/\n\s*<\/Routes>/);
      
      if (routesEndMatch && routesEndMatch.index) {
        const endIndex = routesStartIndex + routesEndMatch.index;
        appContent = appContent.slice(0, routesStartIndex) + appContent.slice(endIndex);
        console.log(`  ‚úì Removed existing auto-generated routes`);
      }
    }
    
    // Find the position to insert routes (before the closing </Routes> tag)
    const routesEndMatch = appContent.match(/(\s*)<\/Routes>/);
    if (!routesEndMatch) {
      stats.errors.push('Could not find </Routes> tag in App.tsx');
      console.error(`‚ùå Could not find </Routes> tag`);
      return;
    }
    
    const insertPosition = appContent.indexOf('</Routes>');
    
    // Insert generated routes
    const routesSection = '\n\n              {/* Auto-generated service pages */}\n' + routeElements.join('\n') + '\n';
    appContent = appContent.slice(0, insertPosition) + routesSection + '            ' + appContent.slice(insertPosition);
    
    // Write updated App.tsx
    try {
      fs.writeFileSync(appFilePath, appContent, 'utf-8');
      stats.routesGenerated = pagesData.length;
      console.log(`  ‚úì Added ${stats.routesGenerated} routes to App.tsx`);
    } catch (writeError) {
      stats.errors.push(`Failed to write updated App.tsx: ${writeError}`);
      // Restore from backup
      fs.writeFileSync(appFilePath, fs.readFileSync(backupPath, 'utf-8'), 'utf-8');
      console.error(`‚ùå Failed to write App.tsx, restored from backup`);
    }
  } catch (error) {
    stats.errors.push(`Failed to update App.tsx: ${error}`);
    console.error(`‚ùå Failed to update routing configuration: ${error}`);
  }
}

/**
 * Validates page data before generation
 */
function validatePageData(): boolean {
  console.log('\nüîç Validating page data...\n');
  
  let isValid = true;
  const seenUrls = new Set<string>();
  
  // Check total count
  if (pagesData.length !== 150) {
    stats.errors.push(`Expected 150 pages, got ${pagesData.length}`);
    isValid = false;
  } else {
    console.log(`  ‚úì Page count: ${pagesData.length} pages`);
  }
  
  // Validate each page
  for (let i = 0; i < pagesData.length; i++) {
    const page = pagesData[i];
    
    // Check for duplicate URLs
    if (seenUrls.has(page.url)) {
      stats.errors.push(`Duplicate URL found: ${page.url} at index ${i}`);
      isValid = false;
    }
    seenUrls.add(page.url);
    
    // Check required SEO fields
    if (!page.title || page.title.length === 0) {
      stats.errors.push(`Page ${i}: Missing title`);
      isValid = false;
    }
    
    if (!page.metaDescription || page.metaDescription.length < 150 || page.metaDescription.length > 160) {
      stats.warnings.push(`Page ${i} (${page.url}): Meta description length ${page.metaDescription?.length || 0} (should be 150-160)`);
    }
    
    if (!page.h1 || page.h1.length === 0) {
      stats.errors.push(`Page ${i}: Missing H1`);
      isValid = false;
    }
    
    if (!page.url || !page.url.startsWith('/services/')) {
      stats.errors.push(`Page ${i}: Invalid URL format: ${page.url}`);
      isValid = false;
    }
    
    if (!page.canonicalUrl || !page.canonicalUrl.startsWith('https://')) {
      stats.errors.push(`Page ${i}: Invalid canonical URL: ${page.canonicalUrl}`);
      isValid = false;
    }
    
    // Check required content sections
    if (!page.introduction || page.introduction.length < 100) {
      stats.errors.push(`Page ${i}: Introduction too short or missing`);
      isValid = false;
    }
    
    if (!page.services || page.services.length === 0) {
      stats.errors.push(`Page ${i}: No services listed`);
      isValid = false;
    }
    
    if (!page.process || page.process.length === 0) {
      stats.errors.push(`Page ${i}: No process steps`);
      isValid = false;
    }
    
    if (!page.faqs || page.faqs.length === 0) {
      stats.errors.push(`Page ${i}: No FAQs`);
      isValid = false;
    }
    
    // Check schema
    if (!page.schema || !page.schema.localBusiness || !page.schema.service) {
      stats.errors.push(`Page ${i}: Missing schema markup`);
      isValid = false;
    }
  }
  
  console.log(`  ‚úì Unique URLs: ${seenUrls.size}`);
  console.log(`  ‚úì Validation complete`);
  
  return isValid;
}

/**
 * Main execution
 */
async function main(): Promise<void> {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë    SEO-Optimized Page Generator - A1 Furniture Polish     ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  console.log(`\nGenerating ${pagesData.length} service pages with SEO optimization...\n`);
  
  try {
    // Step 1: Validate page data
    const isValid = validatePageData();
    if (!isValid) {
      console.error('\n‚ùå Validation failed. Please fix errors before generating pages.');
      displaySummary();
      process.exit(1);
    }
    
    // Step 2: Generate SEO-optimized pages (optional enhancement)
    console.log('üîç SEO Integration Available');
    console.log('  Note: Enhanced SEO processing can be enabled by calling generateSEOOptimizedPages()');
    console.log('  Current generation uses existing page data with basic SEO optimization\n');
    
    // Step 3: Generate page files
    generateAllPageFiles();
    
    // Step 4: Update routing configuration
    updateAppRoutes();
    
    // Step 5: Display summary
    displaySummary();
    
    // Exit with appropriate code
    if (stats.errors.length > 0) {
      process.exit(1);
    }
  } catch (error) {
    console.error('\n‚ùå Fatal error:', error);
    stats.errors.push(`Fatal error: ${error}`);
    displaySummary();
    process.exit(1);
  }
}

/**
 * Displays generation summary
 */
function displaySummary(): void {
  console.log('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë                    Generation Summary                      ‚ïë');
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n');
  
  console.log(`üìä Statistics:`);
  console.log(`  ‚Ä¢ Total pages in data: ${pagesData.length}`);
  console.log(`  ‚Ä¢ Files created: ${stats.filesCreated}`);
  console.log(`  ‚Ä¢ Files skipped: ${stats.filesSkipped}`);
  console.log(`  ‚Ä¢ Routes generated: ${stats.routesGenerated}`);
  console.log(`  ‚Ä¢ Errors: ${stats.errors.length}`);
  console.log(`  ‚Ä¢ Warnings: ${stats.warnings.length}`);
  
  // Calculate phase breakdown
  const phase1Count = pagesData.filter(p => p.location === 'Mumbai').length;
  const phase2Count = pagesData.filter(p => p.location !== 'Mumbai').length;
  
  console.log(`\nüìà Page Distribution:`);
  console.log(`  ‚Ä¢ Phase 1 (Mumbai generic): ${phase1Count} pages`);
  console.log(`  ‚Ä¢ Phase 2 (Location-specific): ${phase2Count} pages`);
  
  // Calculate variation breakdown
  const variationCounts = {
    affordable: pagesData.filter(p => p.titleVariation === 'affordable').length,
    'top-rated': pagesData.filter(p => p.titleVariation === 'top-rated').length,
    professional: pagesData.filter(p => p.titleVariation === 'professional').length,
    best: pagesData.filter(p => p.titleVariation === 'best').length,
  };
  
  console.log(`\nüè∑Ô∏è  Title Variations:`);
  console.log(`  ‚Ä¢ Affordable: ${variationCounts.affordable} pages`);
  console.log(`  ‚Ä¢ Top-Rated: ${variationCounts['top-rated']} pages`);
  console.log(`  ‚Ä¢ Professional: ${variationCounts.professional} pages`);
  console.log(`  ‚Ä¢ Best: ${variationCounts.best} pages`);
  
  // Unique counts
  const uniqueLocations = new Set(pagesData.map(p => p.location)).size;
  const uniqueCategories = new Set(pagesData.map(p => p.serviceCategory)).size;
  
  console.log(`\nüåç Coverage:`);
  console.log(`  ‚Ä¢ Unique locations: ${uniqueLocations}`);
  console.log(`  ‚Ä¢ Service categories: ${uniqueCategories}`);
  
  if (stats.warnings.length > 0) {
    console.log(`\n‚ö†Ô∏è  Warnings (${stats.warnings.length}):`);
    stats.warnings.slice(0, 10).forEach(warning => console.log(`  ‚Ä¢ ${warning}`));
    if (stats.warnings.length > 10) {
      console.log(`  ... and ${stats.warnings.length - 10} more warnings`);
    }
  }
  
  if (stats.errors.length > 0) {
    console.log(`\n‚ùå Errors (${stats.errors.length}):`);
    stats.errors.forEach(error => console.log(`  ‚Ä¢ ${error}`));
  } else {
    console.log(`\n‚úÖ All pages generated successfully!`);
    console.log(`\nüìÅ Generated files location: ${pagesDir}`);
    console.log(`üìù Routing updated in: ${appFilePath}`);
  }
  
  console.log('\n' + '‚ïê'.repeat(62));
  
  if (stats.errors.length === 0) {
    console.log('\nüéâ Generation complete! You can now build and deploy your site.');
  }
}

// Run the script
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});
